
== Configuration files today

Today, we deploy end-user configuration files in one of many formats, e.g. XML, JSON, INI.
These configuration files are hand crafted - parsing and definition are done in-consistently
by individual sub-components that offer these configuration file(s).

This leads to, at the very least, these problems:

[horizontal]
Inconsistent interface:: We are unable to offer the same interface across
    all systems and components. We are therefore also not able to offer a generic way to modify
    the configuration files residing on disk through any means other than the hand-crafted
    parser/writer.

Inconsistent naming:: Variable names come in all shapes and sizes. There is no stylistic conformance
    between configuration files, or even within one for that matter.

Deployment/Upgrade:: By deploying a fixed text-based configuration file,
    whenever we install updates or re-install the system, all changes made by the end-user
    will not be automatically re-applyed to the new configuration file. Packaging systems such as
    RPM provide some means to assist in this process, by tagging configuration files as such
    and producing `*.rpm*` backup files when changes are introduced. However, the process of
    re-applying the changes is manual.

Listing available configuration files:: Do you even know what you are looking for to configure
     a component? Unless you do not know the exact location of the configuration file on disk,
     there is no indication by 'The System'â„¢ of what available configurable files it has.


== Disir: Versioned configuration files described by a schema.

The solution to all the problems listed above which we encounter today, can be resolved with
the following solution. I have named this software stack *Disir*.

=== Concept

A schema describes a configuration file - much like XML schemas describe the contents
of a XML file. However, the significant difference lies in the fact that a _Disir Schema_
is one-to-one mapped with a configuration file it represents.

The _Disir Schema_ will describe all key-value pairs, and sections of key-value pairs, of the
configuration file it represent. Every key-value has a default value, all of which are versioned
individually. This allows us to create a version number for the _Disir Schema_.
When installing a configuration file, we will *NOT* install the actual configuration file,
but rather the _Disir Schema_ that describes it.

Then, upon final installation/upgrade, we can inspect all installed _Disir Schema_'s
and generate the _Disir Config_ file. The _Disir Config_ file will have the version number
of its _Disir Schema_.

*Key Point*: No database. Everything shall be fully expressed by the text files in the file
system.

=== Problems addressed

[horizontal]
Inconsistent interface:: This gives us one library interface to iterate all key-value pairs,
    their type, value and restrictions. This allows to create a utility that may manipulate
    any configuration file remotely, through a GUI or Web interface.

Inconsistent naming:: The library for defining te _Disir Schema_ can implement restrictions
    in naming so we align configuration variable naming across systems and components.

Deployment/Upgrade:: Since the _Disir Config_ file is not installed, but rather generated/updated
    on the system post-install/upgrade based on its _Disir Schema_.
    If a _Disir Config_ already exist on the system, with a lower version number than the
    installed _Disir Schema_, we can attempt to automatically merge end-user changes to key-values
    that has not changed in the _Disir Schema_. If there are changes in both the _Disir Config_
    and the updated _Disir Schema_, manual merge strategies must be employed (much like
    our version control systems do today!)

Listing available configuration file:: The _Disir Schema_ are all installed in a controlled,
    well-defined folder structure. We know exactly which configuration files we have available!

== Example

This section illustrations the problem, and then the _Disir_ solution. The represented
text format used in XML, however it is applicable to all formats.

[[initial-config-xml]]
.Initial Config
[source, xml]
----
<config>
  <country>Norway</country>
  <timeout>10</timeout>
</config>
----

Here we have one variable, `country`, which will not change from our side, but the end-user will change
it because she doesn't live in Norway. However, the `timeout` configuration is reasonable, so it will not be changed.


=== Problem

.End-user changes `country`
[source, xml]
----
<config>
  <country>Greece</country>
  <timeout>10</timeout>
</config>
----

Now lets say we modify our system and find out that the correct `timeout` should now be 20,
we will install upon next release this file:

.Install `timeout` update
[source, xml]
----
<config>
  <country>Norway</country>
  <timeout>50</timeout>
</config>
----

Now we have overwritten the changes made by the end-user, even tho we did not alter the key-value
the end-user had changes.

=== Solution

If we instead of installing the XML file in <<initial-config-xml>>, we rather install a
_Disir Schema_ that could look something like this:

.Initial Schema version 1.0.0
[source, xml]
----
<disir_schema>
  <keyval name="country" type="string">
    <documentation>The country where the installation is located.</documentation>
    <default>Norway</default>
  </keyval>
  <keyval name="timeout" type="int">
    <documentation>Timeout in seconds before pass is aborted after no more data received</documentation>
    <default>10</default>
  </keyval>
</disir_schema>
----

With this _Disir Schema_, we can generate the XML configuration file found
in <<initial-config-xml>>.

Now say we need to update the `timeout` to a new value, we will simply update the
_Disir Schema_ like this:

.Updated Schema version 1.1.0
[source, xml]
----
<disir_schema>
  <keyval name="country" type="string">
    <documentation>The country where the installation is located.</documentation>
    <default>Norway</default>
  </keyval>
  <keyval name="timeout" type="int">
    <documentation>Timeout in seconds before pass is aborted after no more data received</documentation>
    <default>10</default>
    <default introduced="1.1.0">50</default>
  </keyval>
</disir_schema>
----

With the content of the initial generated XML file, and the updated _Disir Schema_, we
can automatically produce the following XML file by merging the two:

.Merged XML file version 1.1.0
[source, xml]
----
<config disir="1.1.0">
  <country>Greece</country>
  <timeout>50</timeout>
</config>
----


== TODO List

* Complete the C/C++ library to provide the object model for _Disir Schema_, and the verification
of the configuration files according to their schema. This is a work-in-progress.

* Create generic XML and JSON input/output parsers to build the _Disir_ object in memory.

* Create a Command-Line-Interface (CLI) utility that interfaces with the library to perform
update, upgrade, generation, verify etc. operations on installed _Disir_ schemas/configs.

* Create a Ruby binding to the C/C++ library, so that we may use the full power of
our configuration file handling in our scriting language of choice. There exists mulitple
good tools to make this process quite painless.

* Create a GTK/Java FX/Qt GUI utility to manipulate a _Disir Config_ file, in accordance with
its installed _Disir Schema_. Similar to how `mxmled` is for generic XML files; however, this has
a stricter interface and should be easier to extend with add/remove node capabilities.

