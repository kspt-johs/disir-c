#ifndef _LIBDISIR_TEST_HELPER_H
#define _LIBDISIR_TEST_HELPER_H

#include <gtest/gtest.h>

extern "C" {
#include "log.h"
}

#include <disir/disir.h>
#include <disir/context.h>

// XXX: Remove me when ConfigSerializeUnserializeCompare hack is fixed
#include <disir/fslib/toml.h>
// XXX: REmove me when/if we get the mold form config from API instead of stealing it from config
extern "C" {
#include "config.h"
}

#define CMAKE_BUILD_DIRECTORY "@CMAKE_BINARY_DIR@"
#define CMAKE_SOURCE_DIRECTORY "@CMAKE_SOURCE_DIR@"

#define ASSERT_STATUS(a,b)                                                  \
    {                                                                       \
        if (a != b)                                                         \
        {                                                                   \
            _log_disir_level (DISIR_LOG_LEVEL_TEST,                         \
                              "STATUS ASSERT FAILED %s vs %s (%s:%d)",      \
                              disir_status_string (a),                      \
                              disir_status_string (b),                      \
                              __FUNCTION__, __LINE__                        \
                             );                                             \
            FAIL() << "Asserted status '"                                   \
                   << disir_status_string (a)                               \
                   << " (" << a << ")'"                                     \
                   << ", got '"                                             \
                   << disir_status_string (b)                               \
                   << " (" << b << ")'";                                    \
        }                                                                   \
    }

#define EXPECT_STATUS(a,b)                                                  \
    {                                                                       \
        if (a != b)                                                         \
        {                                                                   \
            _log_disir_level (DISIR_LOG_LEVEL_TEST,                         \
                              "STATUS ASSERT FAILED %s vs %s (%s:%d)",      \
                              disir_status_string (a),                      \
                              disir_status_string (b),                      \
                              __FUNCTION__, __LINE__                        \
                             );                                             \
            ADD_FAILURE() << "Expected status '"                            \
                   << disir_status_string (a)                               \
                   << " (" << a << ")'"                                     \
                   << ", got '"                                             \
                   << disir_status_string (b)                               \
                   << " (" << b << ")'";                                    \
        }                                                                   \
    }


#define ASSERT_NO_SETUP_FAILURE()                                           \
    {                                                                       \
        if (HasFatalFailure()) return;                                      \
    }

namespace testing
{
    class DisirTestWrapper : public testing::Test
    {
    protected:
        void DisirLogCurrentTest (const char *prefix);

        void DisirLogCurrentTestEnter ();

        void DisirLogCurrentTestExit ();

        void DisirLogTestBodyEnter ();
        void DisirLogTestBodyExit ();
    };

    class DisirTestTestPlugin : public DisirTestWrapper
    {
    protected:

        static void SetUpTestCase ();
        static void TearDownTestCase ();

        void SetUp ()
        {
            DisirLogCurrentTestEnter ();
        }

        void TearDown ()
        {
            DisirLogCurrentTestExit ();
        }

        // TODO: Create dio_fslib_serialize and dio_fslib_unserialize typedefs
        void ConfigSerializeUnserializeCompareAll (void)
        {
            // Iterate all available configs
            struct disir_entry *entries = NULL;
            struct disir_entry *current = NULL;
            struct disir_entry *next = NULL;

            status = disir_config_entries (instance, &entries);
            ASSERT_STATUS (DISIR_STATUS_OK, status);
            ASSERT_TRUE (entries != NULL);

            current = entries;
            while (current != NULL)
            {
                next = current->next;

                DisirLogCurrentTest (current->de_entry_name);
                serialize_unserialize_compare_single (current->de_entry_name);

                disir_entry_finished (&current);
                current = next;
            }
        }

        // XXX: Using hardcoded toml serialize/unserialize for now.
        // XXX: This should be replaced with generic fslib plugin signatures
        void serialize_unserialize_compare_single (const char *entry)
        {
            struct disir_config *config_original = NULL;
            struct disir_config *config_parsed = NULL;
            struct disir_context *context_config1 = NULL;
            struct disir_context *context_config2 = NULL;
            FILE *file = NULL;
            struct disir_mold *mold = NULL;

            // read the current entry
            status = disir_config_read (instance, entry,
                                        NULL, &config_original);
            EXPECT_STATUS (DISIR_STATUS_OK, status);
            if (status != DISIR_STATUS_OK)
            {
                DisirLogCurrentTest (disir_status_string (status));
                goto out;
            }

            // open file for reading and writing
            char filepath[4098];
            snprintf (filepath, 4098, "/tmp/disir_plugin_serialize_unserialize_%s.toml", entry);
            file = fopen (filepath, "w+");
            EXPECT_TRUE (file != NULL);
            if (file == NULL)
            {
                DisirLogCurrentTest ("Failed to open file...");
                goto out;
            }

            // Serialize the current entry config
            status = dio_toml_serialize_config (config_original, file);
            EXPECT_STATUS (DISIR_STATUS_OK, status);
            if (status != DISIR_STATUS_OK)
                goto out;

            // Unserialize the previously serialized config
            // XXX: Cheat by extracting the mold directly from the config.
            mold = config_original->cf_mold;
            fseek (file, 0, SEEK_SET);
            status = dio_toml_unserialize_config (instance, file, mold, &config_parsed);
            EXPECT_STATUS (DISIR_STATUS_OK, status);
            if (status != DISIR_STATUS_OK)
                goto out;

            // compare the two
            context_config1 = dc_config_getcontext (config_original);
            context_config2 = dc_config_getcontext (config_parsed);
            EXPECT_TRUE (context_config1 != NULL);
            EXPECT_TRUE (context_config2 != NULL);
            if (context_config1 == NULL || context_config2 == NULL)
                goto out;
            status = dc_compare (context_config1, context_config2, NULL);
            EXPECT_STATUS (DISIR_STATUS_OK, status)

        out:
            DisirLogCurrentTest ("compare serialize-unserialize out clause");
            // Cleanup this entry and move to the next
            if (file != NULL)
            {
                fclose (file);
            }
            dc_putcontext (&context_config1);
            dc_putcontext (&context_config2);
            disir_config_finished (&config_original);
            disir_config_finished (&config_parsed);
        }

    public:
        static struct disir_instance   *instance;
        static struct disir_mold    *libdisir_mold;
        static struct disir_config  *libdisir_config;

        enum disir_status status;
    };
}

#endif // _LIBDISIR_TEST_HELPER_H

